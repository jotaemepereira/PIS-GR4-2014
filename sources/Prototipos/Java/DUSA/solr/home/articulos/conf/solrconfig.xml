<?xml version="1.0" encoding="UTF-8" ?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<!--
 This is a stripped down config file used for a simple example...  
 It is *not* a good example to work from. 
-->
<config>
  <luceneMatchVersion>4.10.1</luceneMatchVersion>
  
  <lib dir="../dist/" regex="solr-dataimporthandler-.*\.jar" />

  <lib dir="../contrib/extraction/lib" regex=".*\.jar" />
  <lib dir="../dist/" regex="solr-cell-\d.*\.jar" />

  <lib dir="../contrib/clustering/lib/" regex=".*\.jar" />
  <lib dir="../dist/" regex="solr-clustering-\d.*\.jar" />

  <lib dir="../contrib/langid/lib/" regex=".*\.jar" />
  <lib dir="../dist/" regex="solr-langid-\d.*\.jar" />

  <lib dir="../contrib/velocity/lib" regex=".*\.jar" />
  <lib dir="../dist/" regex="solr-velocity-\d.*\.jar" />
 
  <lib dir="../contrib/dataimporthandler-extras/lib/" regex=".*\.jar" />
  
  <lib dir="./lib" regex=".*\.jar" />
  
  <!--  The DirectoryFactory to use for indexes.
        solr.StandardDirectoryFactory, the default, is filesystem based.
        solr.RAMDirectoryFactory is memory based, not persistent, and doesn't work with replication. -->
  <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>

  <dataDir>${solr.articulos.data.dir:}</dataDir>

  <codecFactory class="solr.SchemaCodecFactory"/>
  
  <!-- To enable dynamic schema REST APIs, use the following for <schemaFactory>:
  
       <schemaFactory class="ManagedIndexSchemaFactory">
         <bool name="mutable">true</bool>
         <str name="managedSchemaResourceName">managed-schema</str>
       </schemaFactory>
       
       When ManagedIndexSchemaFactory is specified, Solr will load the schema from
       he resource named in 'managedSchemaResourceName', rather than from schema.xml.
       Note that the managed schema resource CANNOT be named schema.xml.  If the managed
       schema does not exist, Solr will create it after reading schema.xml, then rename
       'schema.xml' to 'schema.xml.bak'. 
       
       Do NOT hand edit the managed schema - external modifications will be ignored and
       overwritten as a result of schema modification REST API calls.

       When ManagedIndexSchemaFactory is specified with mutable = true, schema
       modification REST API calls will be allowed; otherwise, error responses will be
       sent back for these requests. 
  -->
  <schemaFactory class="ClassicIndexSchemaFactory"/>
  
  
  <indexConfig>
	<lockType>${solr.lock.type:native}</lockType>
	<infoStream>true</infoStream>
  </indexConfig>
  
  <jmx />
  
  <updateHandler class="solr.DirectUpdateHandler2">
	<updateLog>
		  <str name="dir">${solr.ulog.dir:}</str>
	</updateLog>
  
	<autoCommit>
		  <maxTime>${solr.autoCommit.maxTime:15000}</maxTime>
		  <openSearcher>false</openSearcher>
	</autoCommit>
	  
	<autoSoftCommit>
		  <maxTime>${solr.autoSoftCommit.maxTime:1000}</maxTime>
	</autoSoftCommit>
  </updateHandler>
  
  <query>
	<maxBooleanClauses>1024</maxBooleanClauses>
	<filterCache class="solr.FastLRUCache"
                 size="512"
                 initialSize="512"
                 autowarmCount="0"/>
	<queryResultCache class="solr.LRUCache"
                      size="512"
                      initialSize="512"
                      autowarmCount="0"/>
	<documentCache class="solr.LRUCache"
                   size="512"
                   initialSize="512"
                   autowarmCount="0"/>
	<enableLazyFieldLoading>true</enableLazyFieldLoading>
	<queryResultWindowSize>20</queryResultWindowSize>
	<queryResultMaxDocsCached>200</queryResultMaxDocsCached>
	<listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <!--
           <lst><str name="q">solr</str><str name="sort">price asc</str></lst>
           <lst><str name="q">rocks</str><str name="sort">weight asc</str></lst>
          -->
      </arr>
    </listener>
    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst>
          <str name="q">static firstSearcher warming in solrconfig.xml</str>
        </lst>
      </arr>
    </listener>
	<useColdSearcher>false</useColdSearcher>
    <maxWarmingSearchers>2</maxWarmingSearchers>

  </query>
  
  <requestDispatcher handleSelect="false" >
	<requestParsers enableRemoteStreaming="true"
                    multipartUploadLimitInKB="2048000"
                    formdataUploadLimitInKB="2048"
                    addHttpRequestToContext="false"/>
	<httpCaching never304="true" />
  </requestDispatcher>
  
  <!--
        [DUSA-INI]  Agregado por SEBA CERVANTES para sincornizar la base de datos
    -->
    <requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler">
        <lst name="defaults">
            <str name="config">data-config.xml</str>
        </lst>
    </requestHandler>
    <!--
        [DUSA-FIN]
    -->
	
	
	<!-- SearchHandler

       http://wiki.apache.org/solr/SearchHandler

       For processing Search Queries, the primary Request Handler
       provided with Solr is "SearchHandler" It delegates to a sequent
       of SearchComponents (see below) and supports distributed
       queries across multiple shards
    -->
  <requestHandler name="/select" class="solr.SearchHandler">
    <!-- default values for query parameters can be specified, these
         will be overridden by parameters in the request
      -->
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>

        <!--
            [DUSA-INI]
        -->
        <str name="df">DESCRIPTION</str>

        <str name="buildOnOptimize">true</str>
        <!-- SPELLCHECK CUSTOMIZADO SEBA CERVANTES -->
        <!-- Optional, must match spell checker's name as defined above, defaults to "default" -->
        <str name="spellcheck.dictionary">default</str>
        <!-- Also generate Word Break Suggestions (Solr 4.0 see SOLR-2993) -->
        <str name="spellcheck.dictionary">wordbreak</str>
        <!-- omp = Only More Popular -->
        <str name="spellcheck.onlyMorePopular">false</str>
        <!-- exr = Extended Results -->
        <str name="spellcheck.extendedResults">true</str>

        <str name="spellcheck.collate">true</str>
        <str name="spellcheck.maxCollations">7</str>
        <str name="spellcheck.maxCollationTries">3</str>

        <!--  The number of suggestions to return -->
        <str name="spellcheck.count">5</str>
        <!--
            [DUSA-FIN]
        -->
    </lst>

    <!--
        [DUSA-INI]
    -->
    <!-- SEBA CEERVANTES SPELLCHECK -->
    <arr name="last-components">
        <str>spellcheck</str>
    </arr>
    <!--
        [DUSA-FIN]
    -->
  </requestHandler>
  
  <!-- A request handler that returns indented JSON by default -->
  <requestHandler name="/query" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
      <str name="df">text</str>
    </lst>
  </requestHandler>

  <!-- realtime get handler, guaranteed to return the latest stored fields 
    of any document, without the need to commit or open a new searcher. The current 
    implementation relies on the updateLog feature being enabled. -->
  <requestHandler name="/get" class="solr.RealTimeGetHandler">
    <lst name="defaults">
      <str name="omitHeader">true</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
    </lst>
  </requestHandler>
  
    <!-- A Robust Example

       This example SearchHandler declaration shows off usage of the
       SearchHandler with many defaults declared

       Note that multiple instances of the same Request Handler
       (SearchHandler) can be registered multiple times with different
       names (and different init parameters)
    -->
  <requestHandler name="/browse" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>

      <!-- VelocityResponseWriter settings -->
      <str name="wt">velocity</str>
      <str name="v.template">browse</str>
      <str name="v.layout">layout</str>
      <str name="title">Solritas</str>

      <!-- Query settings -->
      <str name="defType">edismax</str>
      <str name="qf">
        text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
        title^10.0 description^5.0 keywords^5.0 author^2.0 resourcename^1.0
      </str>
      <str name="df">text</str>
      <str name="mm">100%</str>
      <str name="q.alt">*:*</str>
      <str name="rows">10</str>
      <str name="fl">*,score</str>

      <str name="mlt.qf">
        text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
        title^10.0 description^5.0 keywords^5.0 author^2.0 resourcename^1.0
      </str>
      <str name="mlt.fl">text,features,name,sku,id,manu,cat,title,description,keywords,author,resourcename</str>
      <int name="mlt.count">3</int>

      <!-- Faceting defaults -->
      <str name="facet">on</str>
      <str name="facet.field">cat</str>
      <str name="facet.field">manu_exact</str>
      <str name="facet.field">content_type</str>
      <str name="facet.field">author_s</str>
      <str name="facet.query">ipod</str>
      <str name="facet.query">GB</str>
      <str name="facet.mincount">1</str>
      <str name="facet.pivot">cat,inStock</str>
      <str name="facet.range.other">after</str>
      <str name="facet.range">price</str>
      <int name="f.price.facet.range.start">0</int>
      <int name="f.price.facet.range.end">600</int>
      <int name="f.price.facet.range.gap">50</int>
      <str name="facet.range">popularity</str>
      <int name="f.popularity.facet.range.start">0</int>
      <int name="f.popularity.facet.range.end">10</int>
      <int name="f.popularity.facet.range.gap">3</int>
      <str name="facet.range">manufacturedate_dt</str>
      <str name="f.manufacturedate_dt.facet.range.start">NOW/YEAR-10YEARS</str>
      <str name="f.manufacturedate_dt.facet.range.end">NOW</str>
      <str name="f.manufacturedate_dt.facet.range.gap">+1YEAR</str>
      <str name="f.manufacturedate_dt.facet.range.other">before</str>
      <str name="f.manufacturedate_dt.facet.range.other">after</str>

      <!-- Highlighting defaults -->
      <str name="hl">on</str>
      <str name="hl.fl">content features title name</str>
      <str name="hl.encoder">html</str>
      <str name="hl.simple.pre">&lt;b&gt;</str>
      <str name="hl.simple.post">&lt;/b&gt;</str>
      <str name="f.title.hl.fragsize">0</str>
      <str name="f.title.hl.alternateField">title</str>
      <str name="f.name.hl.fragsize">0</str>
      <str name="f.name.hl.alternateField">name</str>
      <str name="f.content.hl.snippets">3</str>
      <str name="f.content.hl.fragsize">200</str>
      <str name="f.content.hl.alternateField">content</str>
      <str name="f.content.hl.maxAlternateFieldLength">750</str>

      <!-- Spell checking defaults -->
      <str name="spellcheck">on</str>
      <str name="spellcheck.extendedResults">false</str>
      <str name="spellcheck.count">5</str>
      <str name="spellcheck.alternativeTermCount">2</str>
      <str name="spellcheck.maxResultsForSuggest">5</str>
      <str name="spellcheck.collate">true</str>
      <str name="spellcheck.collateExtendedResults">true</str>
      <str name="spellcheck.maxCollationTries">5</str>
      <str name="spellcheck.maxCollations">3</str>
    </lst>

    <!-- append spellchecking to our list of components -->
    <arr name="last-components">
      <str>spellcheck</str>
    </arr>
  </requestHandler>
  
  <requestHandler name="/update" class="solr.UpdateRequestHandler">
    <!-- See below for information on defining
         updateRequestProcessorChains that can be used by name
         on each Update Request
      -->
    <lst name="defaults">
      <str name="update.chain">add-unknown-fields-to-the-schema</str>
    </lst>
  </requestHandler>
  
  <!-- for back compat with clients using /update/json and /update/csv -->
  <requestHandler name="/update/json" class="solr.UpdateRequestHandler">
    <lst name="defaults">
      <str name="stream.contentType">application/json</str>
      <str name="update.chain">add-unknown-fields-to-the-schema</str>
    </lst>
  </requestHandler>
  <requestHandler name="/update/csv" class="solr.UpdateRequestHandler">
    <lst name="defaults">
      <str name="stream.contentType">application/csv</str>
      <str name="update.chain">add-unknown-fields-to-the-schema</str>
    </lst>
  </requestHandler>

  <!-- Solr Cell Update Request Handler

       http://wiki.apache.org/solr/ExtractingRequestHandler

    -->
  <requestHandler name="/update/extract"
                  startup="lazy"
                  class="solr.extraction.ExtractingRequestHandler" >
    <lst name="defaults">
      <str name="lowernames">true</str>
      <str name="uprefix">ignored_</str>

      <!-- capture link hrefs but ignore div attributes -->
      <str name="captureAttr">true</str>
      <str name="fmap.a">links</str>
      <str name="fmap.div">ignored_</str>
    </lst>
  </requestHandler>
  
  <!-- Field Analysis Request Handler

       RequestHandler that provides much the same functionality as
       analysis.jsp. Provides the ability to specify multiple field
       types and field names in the same request and outputs
       index-time and query-time analysis for each of them.

       Request parameters are:
       analysis.fieldname - field name whose analyzers are to be used

       analysis.fieldtype - field type whose analyzers are to be used
       analysis.fieldvalue - text for index-time analysis
       q (or analysis.q) - text for query time analysis
       analysis.showmatch (true|false) - When set to true and when
           query analysis is performed, the produced tokens of the
           field value analysis will be marked as "matched" for every
           token that is produces by the query analysis
   -->
  <requestHandler name="/analysis/field"
                  startup="lazy"
                  class="solr.FieldAnalysisRequestHandler" />
				  
  <requestHandler name="/analysis/document"
                  class="solr.DocumentAnalysisRequestHandler"
                  startup="lazy" />
				  
  <requestHandler name="/admin/" class="org.apache.solr.handler.admin.AdminHandlers" />
  
  <requestHandler name="/admin/ping" class="solr.PingRequestHandler">
    <lst name="invariants">
      <str name="q">solrpingquery</str>
    </lst>
    <lst name="defaults">
      <str name="echoParams">all</str>
    </lst>
  </requestHandler>
  
  <!-- Echo the request contents back to the client -->
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler" >
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="echoHandler">true</str>
    </lst>
  </requestHandler>
  
  <requestHandler name="/replication" class="solr.ReplicationHandler" startup="lazy" /> 
  
  
  <!-- Spell Check

       The spell check component can return a list of alternative spelling
       suggestions.

       http://wiki.apache.org/solr/SpellCheckComponent
    -->
  <searchComponent name="spellcheck" class="solr.SpellCheckComponent">

    <!-- [DUSA-INI] -->
    <!--<str name="queryAnalyzerFieldType">text_general</str>-->
    <str name="queryAnalyzerFieldType">text_es_fuzzy</str>
    <!-- [DUSA-FIN -->

    <!-- Multiple "Spell Checkers" can be declared and used by this
         component
      -->
    <!--
        [DUSA-INI] modificaciones al spellcheck
    -->
    <!-- a spellchecker built from a field of the main index -->
    <lst name="spellchecker">
        <str name="name">default</str>
        <!--<str name="field">text</str>-->
        <str name="field">autocompletar</str> <!-- autocompletar = DESCRIPCION + NOMLAB -->
        <str name="classname">solr.DirectSolrSpellChecker</str>

        <str name="buildOnCommit">true</str>
        <str name="spellcheckIndexDir">./spellchecker</str>
        <str name="combineWords">true</str>
        <str name="breakWords">false</str>

        <!-- the spellcheck distance measure used, the default is the internal levenshtein -->
        <!--<str name="distanceMeasure">internal</str>-->
        <str name="distanceMeasure">org.apache.lucene.search.spell.JaroWinklerDistance</str>
        <!-- minimum accuracy needed to be considered a valid spellcheck suggestion -->
        <float name="accuracy">0.3</float>
        <!-- the maximum #edits we consider when enumerating terms: can be 1 or 2 -->
        <int name="maxEdits">2</int>
        <!-- the minimum shared prefix when enumerating terms -->
        <int name="minPrefix">1</int>
        <!-- maximum number of inspections per result. -->
        <int name="maxInspections">5</int>
        <!-- minimum length of a query term to be considered for correction -->
        <int name="minQueryLength">2</int>
        <!-- maximum threshold of documents a query term can appear to be considered for correction -->
        <float name="maxQueryFrequency">0.01</float>
        <!-- uncomment this to require suggestions to occur in 1% of the documents
          <float name="thresholdTokenFrequency">.01</float>
        -->
    </lst>

    <!-- a spellchecker that can break or combine words.  See "/spell" handler below for usage -->
    <lst name="spellchecker">
      <str name="name">wordbreak</str>
      <str name="classname">solr.WordBreakSolrSpellChecker</str>
      <!--<str name="field">name</str>-->
      <str name="field">autocompletar</str>
      <str name="combineWords">true</str>
      <!--<str name="breakWords">true</str>-->
      <str name="breakWords">false</str>
      <int name="maxChanges">10</int>
    </lst>
    <!--
        [DUSA-FIN]
    -->
	
  </searchComponent>

  
  <!-- Term Vector Component

       http://wiki.apache.org/solr/TermVectorComponent
    -->
  <searchComponent name="tvComponent" class="solr.TermVectorComponent"/>

  <!-- A request handler for demonstrating the term vector component

       This is purely as an example.

       In reality you will likely want to add the component to your
       already specified request handlers.
    -->
  <requestHandler name="/tvrh" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="df">text</str>
      <bool name="tv">true</bool>
    </lst>
    <arr name="last-components">
      <str>tvComponent</str>
    </arr>
  </requestHandler>

  <!-- Clustering Component. (Omitted here. See the default Solr example for a typical configuration.) -->

  <!-- Terms Component

       http://wiki.apache.org/solr/TermsComponent

       A component to return terms and document frequency of those
       terms
    -->
  <searchComponent name="terms" class="solr.TermsComponent"/>

  <!-- A request handler for demonstrating the terms component -->
  <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <bool name="terms">true</bool>
      <bool name="distrib">false</bool>
    </lst>
    <arr name="components">
      <str>terms</str>
    </arr>
  </requestHandler>


  <!-- Query Elevation Component

       http://wiki.apache.org/solr/QueryElevationComponent

       a search component that enables you to configure the top
       results for a given query regardless of the normal lucene
       scoring.
    -->
  <searchComponent name="elevator" class="solr.QueryElevationComponent" >
    <!-- pick a fieldType to analyze queries -->
    <str name="queryFieldType">string</str>
    <str name="config-file">elevate.xml</str>
  </searchComponent>

  <!-- A request handler for demonstrating the elevator component -->
  <requestHandler name="/elevate" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="df">text</str>
    </lst>
    <arr name="last-components">
      <str>elevator</str>
    </arr>
  </requestHandler>

  <!-- Highlighting Component

       http://wiki.apache.org/solr/HighlightingParameters
    -->
  <searchComponent class="solr.HighlightComponent" name="highlight">
    <highlighting>
      <!-- Configure the standard fragmenter -->
      <!-- This could most likely be commented out in the "default" case -->
      <fragmenter name="gap"
                  default="true"
                  class="solr.highlight.GapFragmenter">
        <lst name="defaults">
          <int name="hl.fragsize">100</int>
        </lst>
      </fragmenter>

      <!-- A regular-expression-based fragmenter
           (for sentence extraction)
        -->
      <fragmenter name="regex"
                  class="solr.highlight.RegexFragmenter">
        <lst name="defaults">
          <!-- slightly smaller fragsizes work better because of slop -->
          <int name="hl.fragsize">70</int>
          <!-- allow 50% slop on fragment sizes -->
          <float name="hl.regex.slop">0.5</float>
          <!-- a basic sentence pattern -->
          <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
        </lst>
      </fragmenter>

      <!-- Configure the standard formatter -->
      <formatter name="html"
                 default="true"
                 class="solr.highlight.HtmlFormatter">
        <lst name="defaults">
          <str name="hl.simple.pre"><![CDATA[<em>]]></str>
          <str name="hl.simple.post"><![CDATA[</em>]]></str>
        </lst>
      </formatter>

      <!-- Configure the standard encoder -->
      <encoder name="html"
               class="solr.highlight.HtmlEncoder" />

      <!-- Configure the standard fragListBuilder -->
      <fragListBuilder name="simple"
                       class="solr.highlight.SimpleFragListBuilder"/>

      <!-- Configure the single fragListBuilder -->
      <fragListBuilder name="single"
                       class="solr.highlight.SingleFragListBuilder"/>

      <!-- Configure the weighted fragListBuilder -->
      <fragListBuilder name="weighted"
                       default="true"
                       class="solr.highlight.WeightedFragListBuilder"/>

      <!-- default tag FragmentsBuilder -->
      <fragmentsBuilder name="default"
                        default="true"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <!--
        <lst name="defaults">
          <str name="hl.multiValuedSeparatorChar">/</str>
        </lst>
        -->
      </fragmentsBuilder>

      <!-- multi-colored tag FragmentsBuilder -->
      <fragmentsBuilder name="colored"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <lst name="defaults">
          <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
          <str name="hl.tag.post"><![CDATA[</b>]]></str>
        </lst>
      </fragmentsBuilder>

      <boundaryScanner name="default"
                       default="true"
                       class="solr.highlight.SimpleBoundaryScanner">
        <lst name="defaults">
          <str name="hl.bs.maxScan">10</str>
          <str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
        </lst>
      </boundaryScanner>

      <boundaryScanner name="breakIterator"
                       class="solr.highlight.BreakIteratorBoundaryScanner">
        <lst name="defaults">
          <!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
          <str name="hl.bs.type">WORD</str>
          <!-- language and country are used when constructing Locale object.  -->
          <!-- And the Locale object will be used when getting instance of BreakIterator -->
          <str name="hl.bs.language">en</str>
          <str name="hl.bs.country">US</str>
        </lst>
      </boundaryScanner>
    </highlighting>
  </searchComponent>

  <!-- Update Processors

       Chains of Update Processor Factories for dealing with Update
       Requests can be declared, and then used by name in Update
       Request Processors

       http://wiki.apache.org/solr/UpdateRequestProcessor

    -->

  <!-- Add unknown fields to the schema

       An example field type guessing update processor that will
       attempt to parse string-typed field values as Booleans, Longs,
       Doubles, or Dates, and then add schema fields with the guessed
       field types.

       This requires that the schema is both managed and mutable, by
       declaring schemaFactory as ManagedIndexSchemaFactory, with
       mutable specified as true.

       See http://wiki.apache.org/solr/GuessingFieldTypes
    -->
  <updateRequestProcessorChain name="add-unknown-fields-to-the-schema">
    <processor class="solr.RemoveBlankFieldUpdateProcessorFactory"/>
    <processor class="solr.ParseBooleanFieldUpdateProcessorFactory"/>
    <processor class="solr.ParseLongFieldUpdateProcessorFactory"/>
    <processor class="solr.ParseDoubleFieldUpdateProcessorFactory"/>
    <processor class="solr.ParseDateFieldUpdateProcessorFactory">
      <arr name="format">
        <str>yyyy-MM-dd'T'HH:mm:ss.SSSZ</str>
        <str>yyyy-MM-dd'T'HH:mm:ss,SSSZ</str>
        <str>yyyy-MM-dd'T'HH:mm:ss.SSS</str>
        <str>yyyy-MM-dd'T'HH:mm:ss,SSS</str>
        <str>yyyy-MM-dd'T'HH:mm:ssZ</str>
        <str>yyyy-MM-dd'T'HH:mm:ss</str>
        <str>yyyy-MM-dd'T'HH:mmZ</str>
        <str>yyyy-MM-dd'T'HH:mm</str>
        <str>yyyy-MM-dd HH:mm:ss.SSSZ</str>
        <str>yyyy-MM-dd HH:mm:ss,SSSZ</str>
        <str>yyyy-MM-dd HH:mm:ss.SSS</str>
        <str>yyyy-MM-dd HH:mm:ss,SSS</str>
        <str>yyyy-MM-dd HH:mm:ssZ</str>
        <str>yyyy-MM-dd HH:mm:ss</str>
        <str>yyyy-MM-dd HH:mmZ</str>
        <str>yyyy-MM-dd HH:mm</str>
        <str>yyyy-MM-dd</str>
      </arr>
    </processor>
    <processor class="solr.AddSchemaFieldsUpdateProcessorFactory">
      <str name="defaultFieldType">text_general</str>
      <lst name="typeMapping">
        <str name="valueClass">java.lang.Boolean</str>
        <str name="fieldType">booleans</str>
      </lst>
      <lst name="typeMapping">
        <str name="valueClass">java.util.Date</str>
        <str name="fieldType">tdates</str>
      </lst>
      <lst name="typeMapping">
        <str name="valueClass">java.lang.Long</str>
        <str name="valueClass">java.lang.Integer</str>
        <str name="fieldType">tlongs</str>
      </lst>
      <lst name="typeMapping">
        <str name="valueClass">java.lang.Number</str>
        <str name="fieldType">tdoubles</str>
      </lst>
    </processor>
    <processor class="solr.LogUpdateProcessorFactory"/>
    <processor class="solr.RunUpdateProcessorFactory"/>
  </updateRequestProcessorChain>
  
  <queryResponseWriter name="json" class="solr.JSONResponseWriter">
    <!-- For the purposes of the tutorial, JSON responses are written as
     plain text so that they are easy to read in *any* browser.
     If you expect a MIME type of "application/json" just remove this override.
    -->
    <str name="content-type">text/plain; charset=UTF-8</str>
  </queryResponseWriter>

  <!--
     Custom response writers can be declared as needed...
    -->
  <queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" startup="lazy"/>


  <!-- XSLT response writer transforms the XML output by any xslt file found
       in Solr's conf/xslt directory.  Changes to xslt files are checked for
       every xsltCacheLifetimeSeconds.
    -->
  <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
    <int name="xsltCacheLifetimeSeconds">5</int>
  </queryResponseWriter>
  
  <!--
  

  <requestDispatcher handleSelect="true" >
    <requestParsers enableRemoteStreaming="false" multipartUploadLimitInKB="2048" formdataUploadLimitInKB="2048" />
  </requestDispatcher>
  
  <requestHandler name="standard" class="solr.StandardRequestHandler" default="true" />
  <requestHandler name="/analysis/field" startup="lazy" class="solr.FieldAnalysisRequestHandler" />
  

  
-->
  <!-- config for the admin interface --> 
  <admin>
    <defaultQuery>solr</defaultQuery>
  </admin>

</config>

